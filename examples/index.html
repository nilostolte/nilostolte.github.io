<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<title>Nilo Stolte Graphics - Vector Graphics GUIs and Widgets</title>
<meta name="keywords" content="Java, programming, HTML5, Canvas, JavaScript, GUI, UI, user interfaces, Computer Graphics, vector art, SVG, desktop, Android, embedded, typography, fonts, kerning, PDFBox, OOP, HPC, C/C++, research, otf, ttf, OpenType.js, graphics design, technical writing, science, technology, geopolitics, economy, English, French, Portuguese, Spanish, beer labels, technical illustrations, octree, 3D graphics, Clockwidget, Widgets, Real time analog clock, Bezier curves">
<meta name="description" content="Is your app prepared for tomorrow's resolutions? We offer services and promote vector graphics primitives for the development of interfaces (UI, GUI) on desktops, mobile, web, and embedded systems. The objective is better portability across different platforms and languages, as well as a better solution for different displays resolutions. ">
<meta name="author" content="Nilo Stolte">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style>
@font-face {
  font-family: montserrat-regular;
  src: url('Montserrat-Regular.otf')  format('opentype');
}
@font-face {
  font-family: montserrat-bold;
  src: url('Montserrat-Bold.otf')  format('opentype');
}
@font-face {
  font-family: semibold;
  src: url('OpenSans-Semibold.ttf')  format('truetype');
}
@font-face {
  font-family: regular;
  src: url('OpenSans-Regular.ttf')  format('truetype');
}
@font-face {
  font-family: montserrat-semibold;
  src: url('Montserrat-Semibold.otf')  format('opentype');
}
@font-face {
  font-family: italic;
  src: url('OpenSans-SemiBoldItalic.ttf')  format('truetype');
}
@font-face {
  font-family: bold;
  src: url('OpenSans-Bold.ttf')  format('truetype');
}
a { 
	text-decoration: none;
	color: inherit;
}
* {
	margin:0;
	padding:0
}/* for demo only - use a prper reset instead */
h1 {
	font-family: bold; 
	text-align: left;
	font-size: 1.76vw;
	padding-top: 1.5%;
	padding-bottom: 0.8%;
}
p + p {
	padding-top: 0.8%;
}
th {
  padding: 0px;
  margin: 0px;
}

td {
	padding: 0px;
	margin: 0px;
}

table {
    border-spacing: 0px;
	padding: 0px;
	margin: 0px;
}
html {
	width: 100%;
	font-family: regular;
	font-size: 1.7vw;
}
body {
	width:100%;
	text-align:center;
	background:#FFFFFF;
	padding:1% 0;
}
#wrapper {
	width:86%;
	margin:0 auto;
	text-align:left;
	background:#FFFFFF;
	//border:0.2em solid #000;
	padding:5%;
}
#header {
	background:#FFF;
	//border:0.1em solid #000;
	/*zoom:1.0;*/ /* haslayout fix ie*/
	font-family: montserrat-regular;
	font-size: 2.5vw;
}
#header h1, #footer p {
	text-align:center;
	margin:0 0 0 0;
}
#twocolumns {
	position:relative;
	width:100%;
	z-index:2;
	margin:1% 0;
	overflow:hidden;
}
#leftside {
	width:20%;
	z-index:3;
	position:relative;
	float:left;
	text-align: justify;
}
#rightside {
	position:relative;
	z-index:2;
	margin:0 0 0 20%;
	text-align: justify;
	/*zoom:1.0;*//*ie haslayout fix */
}

/* use absolute overlays for full column colours and borders*/
.col {
	width:20%;
	position:absolute;
	z-index:0;
	left:0;
	top:0;
	bottom:0;
	//border:0.1em solid #000;
	background:#FFFFFF;
}
.two {
	background:#FFFFFF;
	left:20%;
	right:0;
	width:auto;
}
.title-text {
	text-align:center;
	color: rgb(47,62,81);
}
.social{
	float: right;
	margin: -3% 0 0 0;
	vertical-align: top;
	width: 10%;
}

.dot {
  height: 0.8vw;
  width: 0.8vw;
  margin: 0 0.7vw 0 0.7vw;
  border-radius: 50%;
  display: inline-block;
}

.dot-gray {
  height: 2px;
  width: 2px;
  transform: matrix(0.707,-0.707,0.707,0.707,1,1);
  margin: 0 0 0.4vw 0;
  display: inline-block;
  background-color: rgb(47,62,81);
}
</style>
</head>

<body>
	<div id="wrapper">
		<div id="header">
			<div style="margin: 0.5% 0 0 0;"></div>
			<div style="position:absolute; left: 50%;"> 
				<div style="margin: 1.8vw 0 0 -4.4vw;"> 
					<div style="margin: 0 0 0 -5px;">    
						<span class="dot-gray" ></span><a href="../research/index.html"><span class="dot" style="background-color: rgb(152,202,62);"></span></a><span class="dot-gray"></span><a href="../vector/index.html"><span class="dot" style="background-color: rgb(59,199,211);"></span></a><span class="dot-gray"></span><a href="../examples/index.html"><span class="dot" style="background-color: rgb(64,184,150);"></span></a><span class="dot-gray"></span><a href="../art/index.html"><span class="dot" style="background-color: rgb(181,172,90);"></a></span><span class="dot-gray"></span>
					</div>
				</div>
			</div>
			<div title="About Nilo Stolte Graphics" class="title-text">
				<a href="../about/index.html">NILO STOLTE <span style="color: rgb(59,199,211)";>GRAPHICS</span></a>
			</div>
			<div class="social">
				<a href="https://twitter.com/nilostolte"><img src="../twitter-logo.svg" style="width:29%; height:29%;  padding-right: 3.5%;"></a><a href="https://github.com/nilostolte"><img src="../github-logo.svg" style="width:29%; height: 29%; padding-left: 3.5%;"></a><a href="https://dev.to/nilostolte"><img src="../dev-logo.svg" style="width:27%; height: 27%; padding-left: 8%;"></a>
			</div>
			<div style="margin-bottom:7%;"></div>
		</div>
		<div id="twocolumns">
			<div id="leftside">
				<p title="Examples of vector GUIs and widgets" style="text-align: center;">
				<img style="width:40%; height: 40%;" src="rocket-icon.svg">
				</p>
				<p style="margin-bottom:250%;"></p>
			</div>
			<div id="rightside">
				<h1 title="Examples of vector GUIs and widgets">Examples</h1>
				<p>
					This section is dedicated to examples of vector graphics use on the web as well as in applications on desktops, etc.
				</p>
				<p>
					This is a work in progress section where increasingly more complex graphics user interfaces are ported to the web using different methods and technologies. Currently Javascript and HTML 5 Canvas is used. HTML 5 Canvas is probably going to be the intermediate medium between future frontend code and the display on the browser. This is the way online games have been working so far and it is a suitable technology for vector GUIs.
				</p>
				<p>
					Below examples illustrate how similar vector graphics primitives are in different platforms.
				</p>
				<a name="clock"></a>
				<h1 title="Real time vector graphics clock written in Java and
JavaScript with HTML 5 Canvas vector primitives"><a href="https://github.com/nilostolte/ClockWidget">ClockWidget</a></h1>
				<p>
					ClockWidget is a real time vector graphics clock inspired in a design found in <span style="font-family: bold;"><a href="https://www.freepik.com/">Freepik</a></span> and written in <span style="font-family: bold;"><a href="https://github.com/nilostolte/ClockWidget/blob/main/com/ClockWidget.java">Java</a></span>. This is an implementation working on desktops, automatically placed at the top right side of the screen.
				</p>
				<p>
					The same analog vector graphics clock appearing below is the same ClockWidget but rewritten in <span style="font-family: bold;"><a href="https://github.com/nilostolte/nilostolte.github.io/blob/main/examples/index.html">JavaScript</a></span> using <span style="font-family: bold;"><a href="https://github.com/nilostolte/nilostolte.github.io/blob/main/examples/index.html">HTML 5 Canvas vector graphics primitives</a></span>. In this implementation every time the width of the browser window changes, the size of the clock also changes. A modifiable map sets the bold parts of this text clickable, independently of size.
				</p>
				<div title="ClockWidget example rewritten in JavaScript" style="text-align: center; margin: 4% 0 4% 0">
					<canvas id="canvas" style="background-color:rgba(0, 0, 0, 0);"></canvas>
				</div>
				<a name="bezier"></a>
				<h1 title="Basic Vector Interface">Basic Vector Interface</h1>
				<p>
					This example coded using HTML 5 Canvas and JavaScript demonstrates simple interactivity in an interface that allows changing a Bezier curve. The picking algorithm just loops into the array containing the coordinates of the control points of the Bezier curve. Once the point  clicked on is found it can be changed by moving the mouse. For more complex objects this scheme is inadequate. One can get constant time picking by organizing the objects in lists or grids (as in menus or in calculator keys), or exploiting some sort of spacial coherence scheme such as BSP tree or quadtree. Although this is more straighforward in Java, on the web this would be more adequate and efficient using WebAssembly.
				</p>
				<div title="Click at any indicated point and drag to change this Bezier curve" 
					style="margin: 4% 0 4% 0; text-align: center;"
					><canvas id="bezier" style="background-color:#FFFFFF; border:1px solid #000000; "></canvas>
				</div>
			</div>

			<div class="col"></div>
			<!-- col one and two supply full length column colours and borders and hold not content -->
			<div class="col two"></div>
		</div>
		<div id="footer">
				<!-- <p>Footer</p> -->
		</div>
	</div>
<script>
<!-- document.body.style.transform = 'scale(' + window.screen.availHeight/800. + ')'; -->
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
var bezpt = -1;
const bez = [ 55, 320, 150, 20, 350, 20, 630, 320 ];
document.getElementById("bezier").addEventListener("mousedown", bezierPicking);
document.getElementById("bezier").addEventListener("mouseup", bezierReset);
document.getElementById("bezier").addEventListener("mousemove", bezierMove);
var size;
var w;
var radius;
var rimgrad;

resizeWindow();
window.addEventListener('resize', resizeWindow);

setInterval(drawClock, 1000);

function resizeWindow() {
	size = window.innerWidth;
	resizeClock();
	resizeBezier();
}

function bezierMove( e ) {
	if (bezpt != -1) {
		var s = screen.availWidth/size;
		var canvas = document.getElementById("bezier");
		var context = canvas.getContext("2d");
		var rect = canvas.getBoundingClientRect();
		bez[bezpt] = (e.clientX-rect.left)*s;
		bez[bezpt+1] = (e.clientY-rect.top)*s;
		<!-- context.clearRect(0, 0, 300, 40); -->
		<!-- context.font = '10pt Calibri'; -->
        <!-- context.fillText("point: "+((e.clientX-rect.left)*s)+" "+((e.clientY-rect.top)*s), 10, 25); -->
		resizeBezier();
	}
}

function bezierReset() {
	bezpt = -1;
}

function bezierPicking( e ) {
	var s = screen.availWidth/size;
	var canvas = document.getElementById("bezier");
	var rect = canvas.getBoundingClientRect();
	var x = (e.clientX-rect.left)*s;
	var y = (e.clientY-rect.top)*s;
	<!-- window.alert("point: ("+x+", "+y); -->
	var i;
	for (i = 0; i < bez.length; i+=2) {
		if ((Math.abs(x - bez[i]) < 4*s) && (Math.abs(y - bez[i+1]) < 4*s)) break;
	}
	bezpt = -1;
	if (i < bez.length) {
		bezpt = i;
		<!-- window.alert("point: "+bezpt); -->
	}
	<!-- window.alert("point: "+bezpt); -->
}

function resizeBezier() {
	var canvas = document.getElementById("bezier");
	canvas.width = size / 2;
	canvas.height = size / 4;
	var s = size / screen.availWidth;
	var ctx = canvas.getContext("2d");

	ctx.beginPath();
	ctx.moveTo(bez[0]*s, bez[1]*s);
	ctx.bezierCurveTo(bez[2]*s, bez[3]*s, bez[4]*s, bez[5]*s, bez[6]*s, bez[7]*s);
	ctx.stroke();
	

	ctx.fillStyle = "#FF0000";
	ctx.beginPath();
	ctx.arc(bez[2]*s, bez[3]*s, 4*s, 0, 2 * Math.PI);
	ctx.fill();
	ctx.beginPath();
	ctx.arc(bez[4]*s, bez[5]*s, 4*s, 0, 2 * Math.PI);
	ctx.fill();
	ctx.strokeStyle = "#FF0000";
	ctx.beginPath();
	ctx.moveTo(bez[0]*s, bez[1]*s);
	ctx.lineTo(bez[2]*s, bez[3]*s);
	ctx.stroke();
	ctx.beginPath();
	ctx.moveTo(bez[4]*s, bez[5]*s);
	ctx.lineTo( bez[6]*s, bez[7]*s);
	ctx.stroke();
	ctx.fillStyle = "#000000";
	ctx.beginPath();
	ctx.arc(bez[0]*s, bez[1]*s, 4*s, 0, 2 * Math.PI);
	ctx.fill();
	ctx.beginPath();
	ctx.arc(bez[6]*s, bez[7]*s, 4*s, 0, 2 * Math.PI);
	ctx.fill();

}

function resizeClock() {
	<!-- size = document.getElementsByTagName('body')[0].clientWidth; -->
	<!-- window.alert(size); -->
	<!-- window.alert("test string"); -->
	canvas.width = size / 5;
	canvas.height = size / 5;
	w = canvas.width / 2;
	ctx.translate(w, w);
	radius = w * 0.90;
	rimgrad = rimGrad(ctx, radius);
	drawClock();
}

function drawClock() {
  drawFace(ctx, radius);
  var r = radius * 0.93;
  drawNumbers(ctx, r);
  drawTime(ctx, r);
}

function drawFace(ctx, radius) {
  drawDial(ctx, radius *0.95);
  drawRim(ctx, radius);
  drawIntRim(ctx, radius);
}

function intRimGrad(ctx, radius) {
	var grad = ctx.createLinearGradient(0, 0, 0, radius*0.9);
	grad.addColorStop(0, "rgb(75,75,75)");
	//grad.addColorStop(0.01, "rgb(100, 100, 100)");
	//grad.addColorStop(0.4, "rgb(100, 100, 100)");
	grad.addColorStop(1, "rgb(250,250,250)");
	return grad;
}

function drawIntRim(ctx, radius) {
	ctx.beginPath();
	ctx.arc(0, 0, radius*0.9, 0, 2*Math.PI);
	ctx.arc(0, 0, radius * 0.88, 0, 2*Math.PI, true);
	ctx.fillStyle = intRimGrad(ctx,radius);
	ctx.fill();
}

function rimGrad(ctx, radius) {
	var grad = ctx.createLinearGradient(0, -radius/2, 0, radius);
	grad.addColorStop(0, "rgb(196,196,196)");
	grad.addColorStop(1, "rgb(75,75,75)");
	return grad;
}

// division between ceiling specular reflexion and shadowed area
function ceilingSpecular(ctx, r) {
	ctx.arc(0,r*0.62,r*1.2,0,2*Math.PI, true);
}

function drawRim(ctx, radius) {
	var r = radius*0.95;
	ctx.beginPath();
	ctx.arc(0, 0, radius, 0, 2*Math.PI);
	ctx.arc(0, 0, radius*0.89, 0, 2*Math.PI, true);
	var grad = ctx.createLinearGradient(0, -radius, 0, radius*0.7);
	grad.addColorStop(0, "rgb(250,250,250)");
	grad.addColorStop(0.1, "rgb(200,200,200)");
	grad.addColorStop(1, "rgb(170, 170, 170)");
	//ctx.fillStyle = "rgb(186, 186, 186)";
	ctx.fillStyle = grad;
	ctx.fill();
	ctx.save();
	ctx.beginPath();
	ctx.arc(0, 0, radius, 0, 2*Math.PI);
	ctx.arc(0, 0, radius*0.89, 0, 2*Math.PI, true);
	ctx.clip();
	ctx.beginPath();
	ceilingSpecular(ctx, r);
	ctx.fillStyle = rimgrad;
	ctx.fill();
	ctx.restore();
}

function drawDial(ctx, radius) {
	ctx.beginPath();
	ctx.arc(0, 0, radius, 0, 2*Math.PI);
	ctx.fillStyle = 'rgb(226, 226, 226)';
	ctx.fill();
	
	ctx.beginPath();
	ctx.fillStyle = 'rgb(216, 216, 216)';
	// for intersection: "source-atop"
	ctx.globalCompositeOperation = "source-atop";
	ceilingSpecular(ctx, radius);
	ctx.fill();
	ctx.globalCompositeOperation = "source-over";
}

function drawNumbers(ctx, radius) {
	var r = radius*0.75;
	ctx.fillStyle = '#333';
	drawHourMark(ctx, r);
	drawMinMark(ctx, r, 0.5235987755982988731);
	drawMinMark(ctx, r, 1.04719755119659775);
}
function drawMinMark(ctx, length, ang) {
	var i;
	var l = length * 1.16;
	var l2 = length * 1.05;
	var dx = length * 0.02;
	ctx.save();
	ctx.rotate(ang);
	for (i = 0; i < 4; i++) {
		ctx.beginPath();
		ctx.moveTo(-dx,-l2);
		ctx.lineTo(dx,-l2);
		ctx.lineTo(dx,-l);
		ctx.lineTo(-dx,-l);
		ctx.closePath();
		ctx.fill();
		ctx.rotate(1.57079632679489662);
	}
	ctx.restore();
}

function drawHourMark(ctx, length) {
	var i;
	var l = length * 1.19;
	var l2 = length * 0.98;
	var dx = length * 0.02;
	ctx.save();
	for (i = 0; i < 4; i++) {
		ctx.beginPath();
		ctx.moveTo(-dx,-l2);
		ctx.lineTo(dx,-l2);
		ctx.lineTo(dx,-l);
		ctx.lineTo(-dx,-l);
		ctx.closePath();
		ctx.fill();
		ctx.rotate(1.57079632679489662);
	}
	ctx.restore();
}


function drawTime(ctx, radius){
    var now = new Date();
    var hour = now.getHours();
    var minute = now.getMinutes();
    var second = now.getSeconds();
	var l = radius*0.75;

    hour=hour%12;
	var s = (second/60.0);
    var m = (s/60.0) +  (minute/60.0);
	var h = (m/12.) + (hour/12.);
	//hour
	drawHour(ctx, 6.283185307179586477 * h, l);
    //minute
    drawMin(ctx, 6.283185307179586477 * m, l);
    // second
    ctx.fillStyle = 'red';
    drawSec(ctx,  6.283185307179586477 * s, l);
    ctx.beginPath();
    ctx.arc(0, 0, radius*0.06, 0, 2*Math.PI);
    ctx.fillStyle = '#333';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(0, 0, radius*0.04, 0, 2*Math.PI);
    ctx.fillStyle = 'rgb(216, 216, 216)';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(0, 0, radius*0.02, 0, 2*Math.PI);
    ctx.fillStyle = 'red';
    ctx.fill();
}

function drawHour(ctx, pos, length) {
    var d1 = length * 0.038;
	var d2 = length * 0.012;
    var w = length  * 0.27;
	var l = length * 0.75;
    ctx.rotate(pos);
    ctx.beginPath();
    ctx.moveTo(-d1,w);
    ctx.lineTo(d1,w);
    ctx.lineTo(d2, -l);
    ctx.lineTo(-d2, -l);
    ctx.closePath();
    ctx.fill();
    ctx.rotate(-pos);
}

function drawMin(ctx, pos, length) {
    var d1 = length * 0.038;
	var d2 = length * 0.006;
    var w = length  * 0.27;
    ctx.rotate(pos);
    ctx.beginPath();
    ctx.moveTo(-d1,w);
    ctx.lineTo(d1,w);
    ctx.lineTo(d2, -length);
    ctx.lineTo(-d2, -length);
    ctx.closePath();
    ctx.fill();
    ctx.rotate(-pos);
}

function drawSec(ctx, pos, length) {
    var dx = length * 0.019;
    var w = length  * 0.22;
    ctx.rotate(pos);
    ctx.beginPath();
    ctx.moveTo(-dx,w);
    ctx.lineTo(dx,w);
    ctx.lineTo(0, -length);
    ctx.closePath();
    ctx.fill();
    ctx.rotate(-pos);
}
</script>
</body>
</html>