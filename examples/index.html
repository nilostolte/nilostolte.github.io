<!DOCTYPE html>
<html>
<head>
<style>
@font-face {
  font-family: normal;
  src: url('OpenSans-Regular.ttf')  format('truetype');
}
@font-face {
  font-family: bold;
  src: url('OpenSans-Bold.ttf')  format('truetype');
}
a { 
	text-decoration: none;
	color: inherit;
}

td {
	padding: 0px 0px 0px 0px;
}

th {
  padding: 0px 0px 0px 0px;
}

table {
    border-spacing: 0px;
}

.par1 {
	font-family: normal; 
	text-align: justify; 
	font-size: 1.7vw;
	padding-right: 5%;
}
.parn {
	font-family: normal; 
	text-align: justify; 
	font-size: 1.7vw;
	padding-top: 0.8%;
	padding-right: 5%;
}
.title {
	font-family: bold; 
	text-align: justify;
	font-size: 1.76vw;
	padding-top: 1.5%;
	padding-right: 5%;
	padding-bottom: 0.8%;
}
</style>
</head>
<body>
<table style="color:rgb(63,63,63);">
	<tr>
		<td rowspan="2" style="width:20%; padding-top: 2%; vertical-align: top; text-align: center;"><img style="width:40%; height: 40%;" src="rocket-icon.svg"></td>
		<td class="title" title="Examples">Examples</td>
	</tr>
	<tr>
		<td class="par1">This section is dedicated to examples of vector graphics use on the web as well as in applications on desktops, etc.
		</td>
	</tr>
	<tr>
		<td></td>
		<td class="parn">This is a work in progress section where increasingly more complex graphics user interfaces are ported to the web using different methods and technologies. Currently Javascript and HTML 5 Canvas is used. HTML 5 Canvas is probably going to be the intermediate medium between future frontend code and the display on the browser. This is the way online games have been working so far and it is a suitable technology for vector GUIs.</td>
	</tr>
	<tr>
		<td></td>
		<td class="parn">Below examples illustrate how similar vector graphics primitives are in different platforms.</td>
	</tr>
	
	<tr>
		<td></td>
		<td class="title" title="ClockWidget"><a href="https://github.com/nilostolte/ClockWidget">ClockWidget</a></td>
	</tr>
	<tr>
		<td style="width:20%;"></td>
		<td class="par1">ClockWidget is a real time vector graphics clock inspired in a design found in <span style="font-family: bold;"><a href="https://www.freepik.com/">Freepik</a></span> and written in <span style="font-family: bold;"><a href="https://github.com/nilostolte/ClockWidget/blob/main/com/ClockWidget.java">Java</a></span>. This is an implementation working on desktops, automatically placed at the top right side of the screen.</td>
	</tr>
	<tr>
		<td></td>
		<td class="parn">The same analog vector graphics clock appearing on the left is ClockWidget rewritten in <span style="font-family: bold;"><a href="https://github.com/nilostolte/nilostolte.github.io/blob/main/examples/index.html">JavaScript</a></span> using <span style="font-family: bold;"><a href="https://github.com/nilostolte/nilostolte.github.io/blob/main/examples/index.html">HTML 5 Canvas vector graphics primitives</a></span>. In this implementation every time the width of the browser window changes, the size of the clock also changes. A modifiable map sets the bold parts of this text clickable, independently of size.</td>
	</tr>
	<tr>
		<td></td>
		<td style="text-align: center; padding-right: 5%;"><canvas id="canvas" style="background-color:rgba(0, 0, 0, 0);"></canvas></td>
	</tr>
	<a name="bezier"></a>
	<tr>
		<td></td>
		<td class="title" title="Basic Vector Interface">Basic Vector Interface</td>
	</tr>
	<tr>
		<td></td>
		<td class="par1">This example coded using HTML 5 Canvas and JavaScript demonstrates simple interactivity in an interface that allows changing a Bezier curve. The picking algorithm just loops into the array containing the coordinates of the control points of the Bezier curve. Once the point  clicked on is found it can be changed by moving the mouse. For more complex objects this scheme is inadequate. One can get constant time picking by organizing the objects in lists or grids (as in menus or in calculator keys), or exploiting some sort of spacial coherence scheme such as BSP tree or quadtree. Although this is more straighforward in Java, on the web this would be more adequate and efficient using WebAssembly.</td>
	</tr>
	<tr>
		<td></td>
		<td title="Click at any indicated point and drag to change this Bezier curve" 
			style="padding-bottom: 2%; padding-top: 2%; text-align: center; padding-right: 5%;"
		><canvas id="bezier" style="background-color:#FFFFFF; border:1px solid #000000; "></canvas></td>
	</tr>
</table>
<script>
<!-- document.body.style.transform = 'scale(' + window.screen.availHeight/800. + ')'; -->
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");
var bezpt = -1;
const bez = [ 55, 320, 150, 20, 350, 20, 630, 320 ];
document.getElementById("bezier").addEventListener("mousedown", bezierPicking);
document.getElementById("bezier").addEventListener("mouseup", bezierReset);
document.getElementById("bezier").addEventListener("mousemove", bezierMove);
var size;
var w;
var radius;
var rimgrad;

resizeWindow();
window.addEventListener('resize', resizeWindow);

setInterval(drawClock, 1000);

function resizeWindow() {
	size = window.innerWidth;
	resizeClock();
	resizeBezier();
}

function bezierMove( e ) {
	if (bezpt != -1) {
		var s = screen.availWidth/size;
		var canvas = document.getElementById("bezier");
		var context = canvas.getContext("2d");
		var rect = canvas.getBoundingClientRect();
		bez[bezpt] = (e.clientX-rect.left)*s;
		bez[bezpt+1] = (e.clientY-rect.top)*s;
		<!-- context.clearRect(0, 0, 300, 40); -->
		<!-- context.font = '10pt Calibri'; -->
        <!-- context.fillText("point: "+((e.clientX-rect.left)*s)+" "+((e.clientY-rect.top)*s), 10, 25); -->
		resizeBezier();
	}
}

function bezierReset() {
	bezpt = -1;
}

function bezierPicking( e ) {
	var s = screen.availWidth/size;
	var canvas = document.getElementById("bezier");
	var rect = canvas.getBoundingClientRect();
	var x = (e.clientX-rect.left)*s;
	var y = (e.clientY-rect.top)*s;
	<!-- window.alert("point: ("+x+", "+y); -->
	var i;
	for (i = 0; i < bez.length; i+=2) {
		if ((Math.abs(x - bez[i]) < 4*s) && (Math.abs(y - bez[i+1]) < 4*s)) break;
	}
	bezpt = -1;
	if (i < bez.length) {
		bezpt = i;
		<!-- window.alert("point: "+bezpt); -->
	}
	<!-- window.alert("point: "+bezpt); -->
}

function resizeBezier() {
	var canvas = document.getElementById("bezier");
	canvas.width = size / 2;
	canvas.height = size / 4;
	var s = size / screen.availWidth;
	var ctx = canvas.getContext("2d");

	ctx.beginPath();
	ctx.moveTo(bez[0]*s, bez[1]*s);
	ctx.bezierCurveTo(bez[2]*s, bez[3]*s, bez[4]*s, bez[5]*s, bez[6]*s, bez[7]*s);
	ctx.stroke();
	

	ctx.fillStyle = "#FF0000";
	ctx.beginPath();
	ctx.arc(bez[2]*s, bez[3]*s, 4*s, 0, 2 * Math.PI);
	ctx.fill();
	ctx.beginPath();
	ctx.arc(bez[4]*s, bez[5]*s, 4*s, 0, 2 * Math.PI);
	ctx.fill();
	ctx.strokeStyle = "#FF0000";
	ctx.beginPath();
	ctx.moveTo(bez[0]*s, bez[1]*s);
	ctx.lineTo(bez[2]*s, bez[3]*s);
	ctx.stroke();
	ctx.beginPath();
	ctx.moveTo(bez[4]*s, bez[5]*s);
	ctx.lineTo( bez[6]*s, bez[7]*s);
	ctx.stroke();
	ctx.fillStyle = "#000000";
	ctx.beginPath();
	ctx.arc(bez[0]*s, bez[1]*s, 4*s, 0, 2 * Math.PI);
	ctx.fill();
	ctx.beginPath();
	ctx.arc(bez[6]*s, bez[7]*s, 4*s, 0, 2 * Math.PI);
	ctx.fill();

}

function resizeClock() {
	<!-- size = document.getElementsByTagName('body')[0].clientWidth; -->
	<!-- window.alert(size); -->
	<!-- window.alert("test string"); -->
	canvas.width = size / 5;
	canvas.height = size / 5;
	w = canvas.width / 2;
	ctx.translate(w, w);
	radius = w * 0.90;
	rimgrad = rimGrad(ctx, radius);
	drawClock();
}

function drawClock() {
  drawFace(ctx, radius);
  var r = radius * 0.93;
  drawNumbers(ctx, r);
  drawTime(ctx, r);
}

function drawFace(ctx, radius) {
  drawDial(ctx, radius *0.95);
  drawRim(ctx, radius);
  drawIntRim(ctx, radius);
}

function intRimGrad(ctx, radius) {
	var grad = ctx.createLinearGradient(0, 0, 0, radius*0.9);
	grad.addColorStop(0, "rgb(75,75,75)");
	//grad.addColorStop(0.01, "rgb(100, 100, 100)");
	//grad.addColorStop(0.4, "rgb(100, 100, 100)");
	grad.addColorStop(1, "rgb(250,250,250)");
	return grad;
}

function drawIntRim(ctx, radius) {
	ctx.beginPath();
	ctx.arc(0, 0, radius*0.9, 0, 2*Math.PI);
	ctx.arc(0, 0, radius * 0.88, 0, 2*Math.PI, true);
	ctx.fillStyle = intRimGrad(ctx,radius);
	ctx.fill();
}

function rimGrad(ctx, radius) {
	var grad = ctx.createLinearGradient(0, -radius/2, 0, radius);
	grad.addColorStop(0, "rgb(196,196,196)");
	grad.addColorStop(1, "rgb(75,75,75)");
	return grad;
}

// division between ceiling specular reflexion and shadowed area
function ceilingSpecular(ctx, r) {
	ctx.arc(0,r*0.62,r*1.2,0,2*Math.PI, true);
}

function drawRim(ctx, radius) {
	var r = radius*0.95;
	ctx.beginPath();
	ctx.arc(0, 0, radius, 0, 2*Math.PI);
	ctx.arc(0, 0, radius*0.89, 0, 2*Math.PI, true);
	var grad = ctx.createLinearGradient(0, -radius, 0, radius*0.7);
	grad.addColorStop(0, "rgb(250,250,250)");
	grad.addColorStop(0.1, "rgb(200,200,200)");
	grad.addColorStop(1, "rgb(170, 170, 170)");
	//ctx.fillStyle = "rgb(186, 186, 186)";
	ctx.fillStyle = grad;
	ctx.fill();
	ctx.save();
	ctx.beginPath();
	ctx.arc(0, 0, radius, 0, 2*Math.PI);
	ctx.arc(0, 0, radius*0.89, 0, 2*Math.PI, true);
	ctx.clip();
	ctx.beginPath();
	ceilingSpecular(ctx, r);
	ctx.fillStyle = rimgrad;
	ctx.fill();
	ctx.restore();
}

function drawDial(ctx, radius) {
	ctx.beginPath();
	ctx.arc(0, 0, radius, 0, 2*Math.PI);
	ctx.fillStyle = 'rgb(226, 226, 226)';
	ctx.fill();
	
	ctx.beginPath();
	ctx.fillStyle = 'rgb(216, 216, 216)';
	// for intersection: "source-atop"
	ctx.globalCompositeOperation = "source-atop";
	ceilingSpecular(ctx, radius);
	ctx.fill();
	ctx.globalCompositeOperation = "source-over";
}

function drawNumbers(ctx, radius) {
	var r = radius*0.75;
	ctx.fillStyle = '#333';
	drawHourMark(ctx, r);
	drawMinMark(ctx, r, 0.5235987755982988731);
	drawMinMark(ctx, r, 1.04719755119659775);
}
function drawMinMark(ctx, length, ang) {
	var i;
	var l = length * 1.16;
	var l2 = length * 1.05;
	var dx = length * 0.02;
	ctx.save();
	ctx.rotate(ang);
	for (i = 0; i < 4; i++) {
		ctx.beginPath();
		ctx.moveTo(-dx,-l2);
		ctx.lineTo(dx,-l2);
		ctx.lineTo(dx,-l);
		ctx.lineTo(-dx,-l);
		ctx.closePath();
		ctx.fill();
		ctx.rotate(1.57079632679489662);
	}
	ctx.restore();
}

function drawHourMark(ctx, length) {
	var i;
	var l = length * 1.19;
	var l2 = length * 0.98;
	var dx = length * 0.02;
	ctx.save();
	for (i = 0; i < 4; i++) {
		ctx.beginPath();
		ctx.moveTo(-dx,-l2);
		ctx.lineTo(dx,-l2);
		ctx.lineTo(dx,-l);
		ctx.lineTo(-dx,-l);
		ctx.closePath();
		ctx.fill();
		ctx.rotate(1.57079632679489662);
	}
	ctx.restore();
}


function drawTime(ctx, radius){
    var now = new Date();
    var hour = now.getHours();
    var minute = now.getMinutes();
    var second = now.getSeconds();
	var l = radius*0.75;

    hour=hour%12;
	var s = (second/60.0);
    var m = (s/60.0) +  (minute/60.0);
	var h = (m/12.) + (hour/12.);
	//hour
	drawHour(ctx, 6.283185307179586477 * h, l);
    //minute
    drawMin(ctx, 6.283185307179586477 * m, l);
    // second
    ctx.fillStyle = 'red';
    drawSec(ctx,  6.283185307179586477 * s, l);
    ctx.beginPath();
    ctx.arc(0, 0, radius*0.06, 0, 2*Math.PI);
    ctx.fillStyle = '#333';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(0, 0, radius*0.04, 0, 2*Math.PI);
    ctx.fillStyle = 'rgb(216, 216, 216)';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(0, 0, radius*0.02, 0, 2*Math.PI);
    ctx.fillStyle = 'red';
    ctx.fill();
}

function drawHour(ctx, pos, length) {
    var d1 = length * 0.038;
	var d2 = length * 0.012;
    var w = length  * 0.27;
	var l = length * 0.75;
    ctx.rotate(pos);
    ctx.beginPath();
    ctx.moveTo(-d1,w);
    ctx.lineTo(d1,w);
    ctx.lineTo(d2, -l);
    ctx.lineTo(-d2, -l);
    ctx.closePath();
    ctx.fill();
    ctx.rotate(-pos);
}

function drawMin(ctx, pos, length) {
    var d1 = length * 0.038;
	var d2 = length * 0.006;
    var w = length  * 0.27;
    ctx.rotate(pos);
    ctx.beginPath();
    ctx.moveTo(-d1,w);
    ctx.lineTo(d1,w);
    ctx.lineTo(d2, -length);
    ctx.lineTo(-d2, -length);
    ctx.closePath();
    ctx.fill();
    ctx.rotate(-pos);
}

function drawSec(ctx, pos, length) {
    var dx = length * 0.019;
    var w = length  * 0.22;
    ctx.rotate(pos);
    ctx.beginPath();
    ctx.moveTo(-dx,w);
    ctx.lineTo(dx,w);
    ctx.lineTo(0, -length);
    ctx.closePath();
    ctx.fill();
    ctx.rotate(-pos);
}

</script>
</body>
</html>
